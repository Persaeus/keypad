{"version":3,"file":"cipher.js","sources":["../js/Components/Component.mjs","../js/Script.mjs","../js/Util/base16.mjs","../js/Util/encode.mjs","../js/Password.mjs","../js/Util/sha256.mjs","../js/Cipher.mjs","../js/Components/Decrypt.mjs","../js/Event.mjs","../js/Components/FormControl.mjs","../js/Components/Fieldset.mjs","../js/Components/Encrypt.mjs","../js/Components/Login.mjs","../js/Components/Register.mjs","../js/Components.mjs","../js/index.js"],"sourcesContent":["/**\n * @abstract\n */\nexport default class Component {\n    /**\n     * @param {HTMLElement} node \n     * @param {Object} _context \n     */\n    constructor(node, _context) {\n        /**\n         * @property {HTMLElement} node\n         */\n        this.node = node\n    }\n}","export default class Script {\n    static #script = document.currentScript\n\n    static event = this.#script.getAttribute('event')\n\n    static salt = this.#script.getAttribute('salt')\n\n    static storage = this.#script.getAttribute('storage')\n\n    static token = this.#script.getAttribute('token')\n}","/**\n * Class responsible for encoding and decoding base16 (hexadecimal).\n */\nexport default class base16 {\n    static encode(data) {\n        return Array\n            .from(new Uint8Array(data))\n            .map((b) => b.toString(16).padStart(2, '0'))\n            .join('')\n    }\n\n    static decode(string) {\n        return new Uint8Array(string.match(/../g).map(h => parseInt(h, 16))).buffer\n    }\n}","export default function encode(value) {\n    return new TextEncoder().encode(value)\n}","import Script from \"./Script.mjs\";\n\nimport base16 from \"./Util/base16.mjs\";\nimport encode from \"./Util/encode.mjs\";\nimport sha256 from \"./Util/sha256.mjs\";\n\nexport default class Password {\n    /** @type {Promise<ArrayBuffer>} - The private, client-side password hash. */\n    #hash\n\n    /** @type {Promise<ArrayBuffer> | null} - The 'shareable', server-side password hash. */\n    hash\n\n    static salt = Script.salt\n\n    static storage = Script.storage\n\n    static token = Script.token\n\n    constructor({ clientHash, serverHash = null }) {\n        this.#hash = clientHash\n\n        this.hash = serverHash\n    }\n\n    /**\n     * Initialize a password instance by hashing a plaintext password.\n     * \n     * @param {string} plaintext \n     * @returns {Password}\n     */\n    static hash(plaintext) {\n        const\n            salt = this.salt,\n            hash = input => sha256(encode(input)),\n            clientHash = hash(plaintext + salt),\n            serverHash = hash(salt + plaintext)\n\n        return new this({ clientHash, serverHash })\n    }\n\n    /**\n     * Recall a previously stored instance from local storage.\n     * \n     * @returns {Promise<Password>}\n     */\n    static async recall() {\n        const\n            stored = this.#retrieve(),\n            iv = base16.decode(stored.iv),\n            encryptedHash = base16.decode(stored.encryptedHash),\n            decryptionKey = await this.#storageEncryptionKey(iv)\n\n        const clientHash = await crypto.subtle.decrypt(\n            { name: \"AES-GCM\", iv },\n            decryptionKey,\n            encryptedHash\n        )\n\n        return new this({ clientHash })\n    }\n\n    /**\n     * Store the password hash in local storage, so it may be\n     * recalled in a subsequent request post-authentication.\n     * \n     * @returns {Promise<Password>}\n     */\n    async remember() {\n        const\n            iv = crypto.getRandomValues(new Uint8Array(16)),\n            encryptionKey = await Password.#storageEncryptionKey(iv),\n            encryptedHash = await crypto.subtle.encrypt(\n                { name: \"AES-GCM\", iv },\n                encryptionKey,\n                await this.#hash\n            )\n\n        Password.#store(iv, encryptedHash)\n\n        return this\n    }\n\n    /**\n     * Retrieve the encrypted hash and corresponding initialization vector\n     * from local storage.\n     * \n     * @returns {{ iv: string, encryptedHash: string }}\n     */\n    static #retrieve() {\n        return JSON.parse(localStorage.getItem(this.storage))\n    }\n\n    /**\n     * Get the key for encrypting and decrypting stored hash.\n     * \n     * @param {ArrayBufferLike} iv \n     * @returns {Promise<CryptoKey>}\n     */\n    static async #storageEncryptionKey(iv) {\n        console.log(this.token)\n        const importedKey = await crypto.subtle.importKey(\n            'raw',\n            encode(this.token),\n            'HKDF',\n            false,\n            ['deriveBits', 'deriveKey'],\n        )\n\n        return await crypto.subtle.deriveKey(\n            {\n                hash: 'SHA-256',\n                info: new ArrayBuffer,\n                name: 'HKDF',\n                salt: iv,\n            },\n            importedKey,\n            { name: 'AES-GCM', length: 256 },\n            true,\n            ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']\n        )\n    }\n\n    /**\n     * Store the given encrypted string using given initialization vector.\n     * \n     * @param {string} iv \n     * @param {string} encryptedHash \n     */\n    static #store(iv, encryptedHash) {\n        localStorage.setItem(\n            this.storage,\n            JSON.stringify({\n                iv: base16.encode(iv),\n                encryptedHash: base16.encode(encryptedHash),\n            })\n        )\n    }\n\n    /**\n     * Use the password to unwrap (decrypt) the given wrapped key using the given salt.\n     * \n     * @param {ArrayBufferLike} wrappedKey \n     * @param {ArrayBufferLike} salt \n     * @returns \n     */\n    async unwrap(wrappedKey, salt, unwrappedKeyAlgorithm = { name: 'RSA-OAEP' }) {\n        const unwrappingKey = await this.#wrappingKey(salt)\n\n        return await crypto.subtle.unwrapKey(\n            'pkcs8',\n            wrappedKey,\n            unwrappingKey,\n            { name: 'AES-GCM', iv: salt },\n            unwrappedKeyAlgorithm,\n            true,\n            ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']\n        )\n    }\n\n    /**\n     * Use the password to wrap (encrypt) the given key using the given salt.\n     * \n     * @param {CryptoKey} key \n     * @param {ArrayBufferLike} salt \n     */\n    async wrap(key, salt) {\n        const wrappingKey = await this.#wrappingKey(salt)\n\n        return await crypto.subtle.wrapKey(\n            'pkcs8',\n            key,\n            wrappingKey,\n            { name: 'AES-GCM', iv: salt }\n        )\n    }\n\n    /**\n     * Get the wrapping key for the given salt.\n     * \n     * @param {ArrayBufferLike} salt \n     * @returns {Promise<CryptoKey>}\n     */\n    async #wrappingKey(salt) {\n        const baseKey = await crypto.subtle.importKey(\n            'raw',\n            await this.#hash,\n            'PBKDF2',\n            false,\n            ['deriveBits', 'deriveKey'],\n        )\n\n        return await crypto.subtle.deriveKey(\n            {\n                salt,\n                name: 'PBKDF2',\n                iterations: 100000,\n                hash: 'SHA-256',\n            },\n            baseKey,\n            { 'name': 'AES-GCM', 'length': 256 },\n            true,\n            ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'],\n        )\n    }\n}","export default function sha256(data) {\n    return crypto.subtle.digest(\n        'SHA-256',\n        data\n    )\n}","import Password from \"./Password.mjs\"\n\nimport base16 from \"./Util/base16.mjs\"\n\nexport default class Cipher {\n    /**\n     * @param {{ salt: ArrayBufferLike, privateKey: CryptoKey, publicKey: CryptoKey }}\n     */\n    constructor({ privateKey, publicKey, salt }) {\n        this.privateKey = privateKey\n\n        this.publicKey = publicKey\n\n        this.salt = salt\n    }\n\n    /**\n     * Encrypt sensitive data using the given password and export the cipher.\n     * \n     * @param {Password} [password]\n     * @returns {Promise<{ k: string, p: string, s: string }>}\n     */\n    async export(password = null) {\n        password ??= await Password.recall()\n\n        const\n            wrappedPrivateKey = password.wrap(this.privateKey, this.salt),\n            exportedPublicKey = crypto.subtle.exportKey(\n                'spki',\n                this.publicKey\n            )\n\n        return {\n            k: base16.encode(await wrappedPrivateKey),\n            p: base16.encode(await exportedPublicKey),\n            s: base16.encode(this.salt)\n        }\n    }\n\n    /**\n     * Generate a new cipher.\n     * \n     * @returns {Promise<Cipher>}\n     */\n    static async generate() {\n        const\n            [salt, keyPair] = await Promise.all([\n                crypto.getRandomValues(new Uint8Array(16)),\n                crypto.subtle.generateKey(\n                    {\n                        name: 'RSA-OAEP',\n                        modulusLength: 4096,\n                        publicExponent: new Uint8Array([1, 0, 1]),\n                        hash: 'SHA-256'\n                    },\n                    true,\n                    ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']\n                )\n            ]),\n            privateKey = keyPair.privateKey,\n            publicKey = keyPair.publicKey\n\n        return new this({ salt, privateKey, publicKey })\n    }\n\n    /**\n     * Parse and decrypt a previously exported cipher using the given password.\n     * \n     * @param {{ k: string, p: string, s: string }}\n     * @param {Password} [password]\n     * @returns {Promise<Cipher>}\n     */\n    static async import({ k, p, s }, password = null) {\n        password ??= await Password.recall()\n\n        const\n            salt = base16.decode(s),\n            exportedPublicKey = base16.decode(p),\n            wrappedPrivateKey = base16.decode(k)\n\n        const [privateKey, publicKey] = await Promise.all([\n            password.unwrap(wrappedPrivateKey, salt),\n            crypto.subtle.importKey(\n                'spki',\n                exportedPublicKey,\n                {\n                    name: 'RSA-OAEP',\n                    hash: 'SHA-256'\n                },\n                true,\n                ['encrypt', 'wrapKey']\n            )\n        ])\n\n        return new this({\n            privateKey,\n            publicKey,\n            salt,\n        })\n    }\n}","import Cipher from \"../Cipher.mjs\";\nimport Component from \"./Component.mjs\";\n\nexport default class Decrypt extends Component {\n    constructor(node, { cipher }) {\n        super(node)\n\n        this.decrypt(Cipher.import(cipher))\n    }\n\n    async decrypt(cipher) {\n        // \n    }\n}","import Script from \"./Script.mjs\"\n\n/**\n * Class responsible for managing events.\n */\nexport default class Event {\n    /**\n     * The name of the event that will be dispatched at the end of\n     * an event interception cycle and, unless stopped, will bubble\n     * to the root and trigger the \"final\" callback.\n     */\n    static event = Script.event\n\n    /** \n     * The event targets and their respective callback stacks, grouped by event type.\n     * \n     * @type {Object<string, WeakMap<EventTarget, {callbacks: ((event: Event) => any)[], final?: (event: Event) => any}>>}\n     */\n    static targets = {}\n\n    /**\n     * Fluently begin constructing a new event interception definition.\n     * \n     * @param {string} event \n     * @returns \n     */\n    static intercept(event) {\n        return new class {\n            /**\n             * Set the event target.\n             * \n             * @param {EventTarget} target \n             * @returns {this}\n             */\n            on(target) {\n                const targets = Event.targets[event] ??= new WeakMap\n\n                if (!targets.has(target)) {\n                    targets.set(target, {\n                        callbacks: []\n                    })\n\n                    Event.#listen(event, target)\n                }\n\n                this.target = targets.get(target)\n\n                return this\n            }\n\n            /**\n             * Add a callback to be run while intercepting event.\n             * \n             * @param {(event: Event) => any} callback \n             * @returns \n             */\n            then(callback) {\n                this.target.callbacks.push(callback)\n\n                return this\n            }\n\n            /**\n             * Set the callback to be run at the end once.\n             * \n             * @param {(event: Event) => any} callback \n             */\n            finally(callback) {\n                this.target.final = callback\n            }\n        }\n    }\n\n    /**\n     * Add the event listener for the given event type and target.\n     * \n     * @param {string} type\n     * @param {EventTarget} target \n     */\n    static #listen(type, target) {\n        target.addEventListener(type, async event => {\n            event.preventDefault()\n\n            const\n                targets = this.targets[type],\n                listener = targets.get(target),\n                callbacks = listener.callbacks,\n                promises = callbacks.map(callback => callback())\n\n            await Promise.all(promises)\n\n            target.dispatchEvent(new CustomEvent(this.event, {\n                bubbles: true,\n                detail: { type }\n            }))\n        })\n\n        document.addEventListener(this.event, event => {\n            if (\n                event.target != target ||\n                event.detail.type != type\n            ) {\n                return\n            }\n\n            this.targets[type].get(target).final(event)\n        })\n    }\n}","import Component from \"./Component.mjs\";\nimport Event from \"../Event.mjs\";\n\n/**\n * @abstract\n */\nexport default class FormControl extends Component {\n    /** @type {HTMLFormElement} */\n    get form() {\n        return this.node.form\n    }\n\n    /**\n     * Intercept the submit event for the component's form using the given callback.\n     * \n     * @param {(event: Event) => any} callback \n     * @returns {void}\n     */\n    onSubmit(callback) {\n        if (!this.form) {\n            throw new Error(`Cipher component \"${this.constructor.name.toLowerCase()}\" must be inside <form> element to intercept submit.`)\n        }\n\n        Event.intercept('submit')\n            .on(this.form)\n            .then(callback.bind(this))\n            .finally(() => this.form.submit())\n    }\n}","import FormControl from \"./FormControl.mjs\";\n\n/**\n * @abstract\n * @property {HTMLFieldSetElement} node\n */\nexport default class Fieldset extends FormControl {\n    /**\n     * Get the form input element with given name.\n     * \n     * @param {string} name \n     * @returns \n     */\n    input(name) {\n        const\n            attribute = 'data-cipher-input',\n            items = this.inputs(name)\n\n        items.forEach(item => item.setAttribute(attribute, name))\n\n        return this.form.querySelector(`[${attribute}='${name}']`)\n    }\n\n    /**\n     * Get all the form control elements with the given name.\n     * \n     * @param {string} name \n     * @returns {HTMLElement[]}\n     */\n    inputs(name) {\n        const\n            item = this.form.elements.namedItem(name),\n            items = typeof item[Symbol.iterator] === 'function'\n                ? [...item]\n                : [item]\n\n        return items.filter(item => !this.node.contains(item))\n    }\n\n    /**\n     * Append to fieldset 'output' field of given \"name\" and \"value\".\n     * \n     * @param {string} name \n     * @param {string} value \n     * @param {boolean} overwrite\n     * @returns \n     */\n    output(name, value, overwrite = true) {\n        const output = this.node.elements.namedItem(name) ?? document.createElement('input')\n\n        output.type = 'hidden'\n        output.name = name\n        output.value = value\n\n        if (!this.node.contains(output)) {\n            this.node.appendChild(output)\n        }\n\n        if (overwrite) {\n            this.inputs(name).forEach(item => item.removeAttribute('name'))\n        }\n\n        return output\n    }\n}","import Fieldset from \"./Fieldset.mjs\";\n\nexport default class Encrypt extends Fieldset {\n    constructor(node, { input, key }) {\n        super(node)\n\n        this.input = input\n\n        this.publicKey = key\n\n        this.onSubmit(this.encrypt)\n    }\n\n    encrypt() {\n        // \n    }\n}","import Fieldset from \"./Fieldset.mjs\";\nimport Password from \"../Password.mjs\";\n\nimport base16 from \"../Util/base16.mjs\";\n\nexport default class Login extends Fieldset {\n    constructor(node, { password }) {\n        super(node)\n\n        this.password = password\n\n        this.onSubmit(this.login)\n    }\n\n    async login() {\n        const\n            plaintextPassword = this.input(this.password).value,\n            password = await Password.hash(plaintextPassword).remember()\n\n        this.output(this.password, base16.encode(await password.hash))\n    }\n}","import Cipher from \"../Cipher.mjs\";\nimport Fieldset from \"./Fieldset.mjs\";\nimport Password from \"../Password.mjs\";\n\nimport base16 from \"../Util/base16.mjs\";\n\nexport default class Register extends Fieldset {\n    constructor(node, { password, confirmation }) {\n        super(node)\n\n        this.password = password\n        this.confirmation = confirmation\n\n        this.onSubmit(this.register)\n    }\n\n    async register() {\n        const\n            plaintextPassword = this.input(this.password).value,\n            password = await Password.hash(plaintextPassword).remember()\n\n        this.output(this.password, base16.encode(await password.hash))\n\n        if (this.confirmation) {\n            const\n                passwordConfirmed = this.input(this.confirmation).value,\n                confirmationHash = Password.hash(passwordConfirmed).hash\n\n            this.output(\n                this.confirmation,\n                base16.encode(await confirmationHash)\n            )\n        }\n\n        const\n            cipher = await Cipher.generate(),\n            exported = await cipher.export(password),\n            json = JSON.stringify(exported)\n\n        this.output('_cipher', json)\n    }\n}","import Component from \"./Components/Component.mjs\"\nimport Decrypt from \"./Components/Decrypt.mjs\"\nimport Encrypt from \"./Components/Encrypt.mjs\"\nimport Login from \"./Components/Login.mjs\"\nimport Register from \"./Components/Register.mjs\"\n\n/**\n * Class responsible for mapping and loading the cipher components.\n */\nexport default class Components {\n    /**\n     * @type {Object.<string, typeof Component>}\n     */\n    static types = {\n        decrypt: Decrypt,\n        encrypt: Encrypt,\n        login: Login,\n        register: Register,\n    }\n\n    /**\n     * Load components on the page.\n     */\n    static load() {\n        document.querySelectorAll('[data-cipher-component]').forEach(node => {\n            const\n                name = node.dataset.cipherComponent,\n                type = this.types[name],\n                attributes = JSON.parse(node.dataset.cipherAttributes),\n                component = new type(node, attributes)\n\n            return component\n        })\n    }\n}","import Components from \"./Components.mjs\";\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    Components.load()\n})"],"names":["Component","constructor","node","_context","this","Script","static","document","currentScript","script","getAttribute","base16","data","Array","from","Uint8Array","map","b","toString","padStart","join","string","match","h","parseInt","buffer","encode","value","TextEncoder","Password","hash","salt","storage","token","clientHash","serverHash","plaintext","input","sha256","crypto","subtle","digest","stored","retrieve","iv","decode","encryptedHash","decryptionKey","storageEncryptionKey","decrypt","name","async","getRandomValues","encryptionKey","encrypt","store","JSON","parse","localStorage","getItem","console","log","importedKey","importKey","deriveKey","info","ArrayBuffer","length","setItem","stringify","wrappedKey","unwrappedKeyAlgorithm","unwrappingKey","wrappingKey","unwrapKey","key","wrapKey","baseKey","iterations","Cipher","privateKey","publicKey","password","recall","wrappedPrivateKey","wrap","exportedPublicKey","exportKey","k","p","s","keyPair","Promise","all","generateKey","modulusLength","publicExponent","unwrap","Decrypt","cipher","super","import","Event","event","on","target","targets","WeakMap","has","set","callbacks","listen","get","then","callback","push","finally","final","type","addEventListener","preventDefault","promises","dispatchEvent","CustomEvent","bubbles","detail","FormControl","form","onSubmit","Error","toLowerCase","intercept","bind","submit","Fieldset","attribute","inputs","forEach","item","setAttribute","querySelector","elements","namedItem","Symbol","iterator","filter","contains","output","overwrite","createElement","appendChild","removeAttribute","Encrypt","Login","login","plaintextPassword","remember","Register","confirmation","register","passwordConfirmed","confirmationHash","generate","exported","export","json","Components","querySelectorAll","dataset","cipherComponent","types","cipherAttributes","component","load"],"mappings":"2FAGe,MAAMA,EAKjBC,YAAYC,EAAMC,GAIdC,KAAKF,KAAOA,CACf,ECbU,MAAMG,EACjBC,SAAiBC,SAASC,cAE1BF,aAAeF,MAAKK,EAAQC,aAAa,SAEzCJ,YAAcF,MAAKK,EAAQC,aAAa,QAExCJ,eAAiBF,MAAKK,EAAQC,aAAa,WAE3CJ,aAAeF,MAAKK,EAAQC,aAAa,SCN9B,MAAMC,EACjBL,cAAcM,GACV,OAAOC,MACFC,KAAK,IAAIC,WAAWH,IACpBI,KAAKC,GAAMA,EAAEC,SAAS,IAAIC,SAAS,EAAG,OACtCC,KAAK,GACb,CAEDd,cAAce,GACV,OAAO,IAAIN,WAAWM,EAAOC,MAAM,OAAON,KAAIO,GAAKC,SAASD,EAAG,OAAME,MACxE,ECbU,SAASC,EAAOC,GAC3B,OAAO,IAAIC,aAAcF,OAAOC,EACpC,CCIe,MAAME,EAEjBC,GAGAA,KAEAxB,YAAcD,EAAO0B,KAErBzB,eAAiBD,EAAO2B,QAExB1B,aAAeD,EAAO4B,MAEtBhC,aAAYiC,WAAEA,EAAUC,WAAEA,EAAa,OACnC/B,MAAK0B,EAAQI,EAEb9B,KAAK0B,KAAOK,CACf,CAQD7B,YAAY8B,GACR,MACIL,EAAO3B,KAAK2B,KACZD,EAAOO,IAASC,OClCG1B,EDkCIc,EAAOW,GCjC/BE,OAAOC,OAAOC,OACjB,UACA7B,GAHO,IAAgBA,CDkCkB,EAIzC,OAAO,IAAIR,KAAK,CAAE8B,WAHDJ,EAAKM,EAAYL,GAGJI,WAFbL,EAAKC,EAAOK,IAGhC,CAOD9B,sBACI,MACIoC,EAAStC,MAAKuC,IACdC,EAAKjC,EAAOkC,OAAOH,EAAOE,IAC1BE,EAAgBnC,EAAOkC,OAAOH,EAAOI,eACrCC,QAAsB3C,MAAK4C,EAAsBJ,GAQrD,OAAO,IAAIxC,KAAK,CAAE8B,iBANOK,OAAOC,OAAOS,QACnC,CAAEC,KAAM,UAAWN,MACnBG,EACAD,IAIP,CAQDK,iBACI,MACIP,EAAKL,OAAOa,gBAAgB,IAAIrC,WAAW,KAC3CsC,QAAsBxB,GAASmB,EAAsBJ,GACrDE,QAAsBP,OAAOC,OAAOc,QAChC,CAAEJ,KAAM,UAAWN,MACnBS,QACMjD,MAAK0B,GAKnB,OAFAD,GAAS0B,EAAOX,EAAIE,GAEb1C,IACV,CAQDE,WACI,OAAOkD,KAAKC,MAAMC,aAAaC,QAAQvD,KAAK4B,SAC/C,CAQD1B,eAAmCsC,GAC/BgB,QAAQC,IAAIzD,KAAK6B,OACjB,MAAM6B,QAAoBvB,OAAOC,OAAOuB,UACpC,MACArC,EAAOtB,KAAK6B,OACZ,QACA,EACA,CAAC,aAAc,cAGnB,aAAaM,OAAOC,OAAOwB,UACvB,CACIlC,KAAM,UACNmC,KAAM,IAAIC,YACVhB,KAAM,OACNnB,KAAMa,GAEVkB,EACA,CAAEZ,KAAM,UAAWiB,OAAQ,MAC3B,EACA,CAAC,UAAW,UAAW,UAAW,aAEzC,CAQD7D,SAAcsC,EAAIE,GACdY,aAAaU,QACThE,KAAK4B,QACLwB,KAAKa,UAAU,CACXzB,GAAIjC,EAAOe,OAAOkB,GAClBE,cAAenC,EAAOe,OAAOoB,KAGxC,CASDK,aAAamB,EAAYvC,EAAMwC,EAAwB,CAAErB,KAAM,aAC3D,MAAMsB,QAAsBpE,MAAKqE,EAAa1C,GAE9C,aAAaQ,OAAOC,OAAOkC,UACvB,QACAJ,EACAE,EACA,CAAEtB,KAAM,UAAWN,GAAIb,GACvBwC,GACA,EACA,CAAC,UAAW,UAAW,UAAW,aAEzC,CAQDpB,WAAWwB,EAAK5C,GACZ,MAAM0C,QAAoBrE,MAAKqE,EAAa1C,GAE5C,aAAaQ,OAAOC,OAAOoC,QACvB,QACAD,EACAF,EACA,CAAEvB,KAAM,UAAWN,GAAIb,GAE9B,CAQDoB,QAAmBpB,GACf,MAAM8C,QAAgBtC,OAAOC,OAAOuB,UAChC,YACM3D,MAAK0B,EACX,UACA,EACA,CAAC,aAAc,cAGnB,aAAaS,OAAOC,OAAOwB,UACvB,CACIjC,OACAmB,KAAM,SACN4B,WAAY,IACZhD,KAAM,WAEV+C,EACA,CAAE3B,KAAQ,UAAWiB,OAAU,MAC/B,EACA,CAAC,UAAW,UAAW,UAAW,aAEzC,EExMU,MAAMY,EAIjB9E,aAAY+E,WAAEA,EAAUC,UAAEA,EAASlD,KAAEA,IACjC3B,KAAK4E,WAAaA,EAElB5E,KAAK6E,UAAYA,EAEjB7E,KAAK2B,KAAOA,CACf,CAQDoB,aAAa+B,EAAW,MACpBA,UAAmBrD,EAASsD,SAE5B,MACIC,EAAoBF,EAASG,KAAKjF,KAAK4E,WAAY5E,KAAK2B,MACxDuD,EAAoB/C,OAAOC,OAAO+C,UAC9B,OACAnF,KAAK6E,WAGb,MAAO,CACHO,EAAG7E,EAAOe,aAAa0D,GACvBK,EAAG9E,EAAOe,aAAa4D,GACvBI,EAAG/E,EAAOe,OAAOtB,KAAK2B,MAE7B,CAODzB,wBACI,MACKyB,EAAM4D,SAAiBC,QAAQC,IAAI,CAChCtD,OAAOa,gBAAgB,IAAIrC,WAAW,KACtCwB,OAAOC,OAAOsD,YACV,CACI5C,KAAM,WACN6C,cAAe,KACfC,eAAgB,IAAIjF,WAAW,CAAC,EAAG,EAAG,IACtCe,KAAM,YAEV,EACA,CAAC,UAAW,UAAW,UAAW,gBAM9C,OAAO,IAAI1B,KAAK,CAAE2B,OAAMiD,WAHPW,EAAQX,WAGWC,UAFpBU,EAAQV,WAG3B,CASD3E,qBAAoBkF,EAAEA,EAACC,EAAEA,EAACC,EAAEA,GAAKR,EAAW,MACxCA,UAAmBrD,EAASsD,SAE5B,MACIpD,EAAOpB,EAAOkC,OAAO6C,GACrBJ,EAAoB3E,EAAOkC,OAAO4C,GAClCL,EAAoBzE,EAAOkC,OAAO2C,IAE/BR,EAAYC,SAAmBW,QAAQC,IAAI,CAC9CX,EAASe,OAAOb,EAAmBrD,GACnCQ,OAAOC,OAAOuB,UACV,OACAuB,EACA,CACIpC,KAAM,WACNpB,KAAM,YAEV,EACA,CAAC,UAAW,cAIpB,OAAO,IAAI1B,KAAK,CACZ4E,aACAC,YACAlD,QAEP,EChGU,MAAMmE,UAAgBlG,EACjCC,YAAYC,GAAMiG,OAAEA,IAChBC,MAAMlG,GAENE,KAAK6C,QAAQ8B,EAAOsB,OAAOF,GAC9B,CAEDhD,cAAcgD,GAEb,ECPU,MAAMG,EAMjBhG,aAAeD,EAAOkG,MAOtBjG,eAAiB,CAAE,EAQnBA,iBAAiBiG,GACb,OAAO,IAAI,MAOPC,GAAGC,GACC,MAAMC,EAAUJ,EAAMI,QAAQH,KAAW,IAAII,QAY7C,OAVKD,EAAQE,IAAIH,KACbC,EAAQG,IAAIJ,EAAQ,CAChBK,UAAW,KAGfR,GAAMS,EAAQR,EAAOE,IAGzBrG,KAAKqG,OAASC,EAAQM,IAAIP,GAEnBrG,IACV,CAQD6G,KAAKC,GAGD,OAFA9G,KAAKqG,OAAOK,UAAUK,KAAKD,GAEpB9G,IACV,CAODgH,QAAQF,GACJ9G,KAAKqG,OAAOY,MAAQH,CACvB,EAER,CAQD5G,SAAegH,EAAMb,GACjBA,EAAOc,iBAAiBD,GAAMnE,UAC1BoD,EAAMiB,iBAEN,MAIIC,EAHUrH,KAAKsG,QAAQY,GACJN,IAAIP,GACFK,UACA9F,KAAIkG,GAAYA,YAEnCtB,QAAQC,IAAI4B,GAElBhB,EAAOiB,cAAc,IAAIC,YAAYvH,KAAKmG,MAAO,CAC7CqB,SAAS,EACTC,OAAQ,CAAEP,UACX,IAGP/G,SAASgH,iBAAiBnH,KAAKmG,OAAOA,IAE9BA,EAAME,QAAUA,GAChBF,EAAMsB,OAAOP,MAAQA,GAKzBlH,KAAKsG,QAAQY,GAAMN,IAAIP,GAAQY,MAAMd,EAAM,GAElD,ECrGU,MAAMuB,UAAoB9H,EAEjC+H,WACA,OAAO3H,KAAKF,KAAK6H,IACpB,CAQDC,SAASd,GACL,IAAK9G,KAAK2H,KACN,MAAM,IAAIE,MAAM,qBAAqB7H,KAAKH,YAAYiD,KAAKgF,qEAG/D5B,EAAM6B,UAAU,UACX3B,GAAGpG,KAAK2H,MACRd,KAAKC,EAASkB,KAAKhI,OACnBgH,SAAQ,IAAMhH,KAAK2H,KAAKM,UAChC,ECrBU,MAAMC,UAAiBR,EAOlCzF,MAAMa,GACF,MACIqF,EAAY,oBAKhB,OAJYnI,KAAKoI,OAAOtF,GAElBuF,SAAQC,GAAQA,EAAKC,aAAaJ,EAAWrF,KAE5C9C,KAAK2H,KAAKa,cAAc,IAAIL,MAAcrF,MACpD,CAQDsF,OAAOtF,GACH,MACIwF,EAAOtI,KAAK2H,KAAKc,SAASC,UAAU5F,GAKxC,OAJ6C,mBAA1BwF,EAAKK,OAAOC,UACrB,IAAIN,GACJ,CAACA,IAEEO,QAAOP,IAAStI,KAAKF,KAAKgJ,SAASR,IACnD,CAUDS,OAAOjG,EAAMvB,EAAOyH,GAAY,GAC5B,MAAMD,EAAS/I,KAAKF,KAAK2I,SAASC,UAAU5F,IAAS3C,SAAS8I,cAAc,SAc5E,OAZAF,EAAO7B,KAAO,SACd6B,EAAOjG,KAAOA,EACdiG,EAAOxH,MAAQA,EAEVvB,KAAKF,KAAKgJ,SAASC,IACpB/I,KAAKF,KAAKoJ,YAAYH,GAGtBC,GACAhJ,KAAKoI,OAAOtF,GAAMuF,SAAQC,GAAQA,EAAKa,gBAAgB,UAGpDJ,CACV,EC7DU,MAAMK,UAAgBlB,EACjCrI,YAAYC,GAAMmC,MAAEA,EAAKsC,IAAEA,IACvByB,MAAMlG,GAENE,KAAKiC,MAAQA,EAEbjC,KAAK6E,UAAYN,EAEjBvE,KAAK4H,SAAS5H,KAAKkD,QACtB,CAEDA,UAEC,ECVU,MAAMmG,UAAcnB,EAC/BrI,YAAYC,GAAMgF,SAAEA,IAChBkB,MAAMlG,GAENE,KAAK8E,SAAWA,EAEhB9E,KAAK4H,SAAS5H,KAAKsJ,MACtB,CAEDvG,cACI,MACIwG,EAAoBvJ,KAAKiC,MAAMjC,KAAK8E,UAAUvD,MAC9CuD,QAAiBrD,EAASC,KAAK6H,GAAmBC,WAEtDxJ,KAAK+I,OAAO/I,KAAK8E,SAAUvE,EAAOe,aAAawD,EAASpD,MAC3D,ECdU,MAAM+H,UAAiBvB,EAClCrI,YAAYC,GAAMgF,SAAEA,EAAQ4E,aAAEA,IAC1B1D,MAAMlG,GAENE,KAAK8E,SAAWA,EAChB9E,KAAK0J,aAAeA,EAEpB1J,KAAK4H,SAAS5H,KAAK2J,SACtB,CAED5G,iBACI,MACIwG,EAAoBvJ,KAAKiC,MAAMjC,KAAK8E,UAAUvD,MAC9CuD,QAAiBrD,EAASC,KAAK6H,GAAmBC,WAItD,GAFAxJ,KAAK+I,OAAO/I,KAAK8E,SAAUvE,EAAOe,aAAawD,EAASpD,OAEpD1B,KAAK0J,aAAc,CACnB,MACIE,EAAoB5J,KAAKiC,MAAMjC,KAAK0J,cAAcnI,MAClDsI,EAAmBpI,EAASC,KAAKkI,GAAmBlI,KAExD1B,KAAK+I,OACD/I,KAAK0J,aACLnJ,EAAOe,aAAauI,GAE3B,CAED,MACI9D,QAAepB,EAAOmF,WACtBC,QAAiBhE,EAAOiE,OAAOlF,GAC/BmF,EAAO7G,KAAKa,UAAU8F,GAE1B/J,KAAK+I,OAAO,UAAWkB,EAC1B,EC/BU,MAAMC,EAIjBhK,aAAe,CACX2C,QAASiD,EACT5C,QAASkG,EACTE,MAAOD,EACPM,SAAUF,GAMdvJ,cACIC,SAASgK,iBAAiB,2BAA2B9B,SAAQvI,IACzD,MACIgD,EAAOhD,EAAKsK,QAAQC,gBAKxB,OAFgB,IAAInD,EAFTlH,KAAKsK,MAAMxH,IAEGhD,EADRsD,KAAKC,MAAMvD,EAAKsK,QAAQG,kBAGlCC,GAEd,EC/BLrK,SAASgH,iBAAiB,oBAAoB,KAC1C+C,EAAWO,MAAM"}