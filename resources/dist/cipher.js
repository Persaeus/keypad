!function(t){"function"==typeof define&&define.amd?define(t):t()}((function(){"use strict";class t{constructor(t,e){this.node=t}}class e{static#t=document.currentScript;static event=this.#t.getAttribute("event");static salt=this.#t.getAttribute("salt");static storage=this.#t.getAttribute("storage")}class s{static encode(t){return Array.from(new Uint8Array(t)).map((t=>t.toString(16).padStart(2,"0"))).join("")}static decode(t){return new Uint8Array(t.match(/../g).map((t=>parseInt(t,16)))).buffer}}class a{#e;hash;static salt=e.salt;static storage=e.storage;static token=e.token;constructor({clientHash:t,serverHash:e=null}){this.#e=t,this.hash=e}static hash(t){const e=this.salt,s=t=>{return s=t,e=(new TextEncoder).encode(s),crypto.subtle.digest("SHA-256",e);var e,s};return new this({clientHash:s(t+e),serverHash:s(e+t)})}static async recall(){const t=localStorage.getItem(this.storage);return new this({clientHash:s.decode(t)})}async remember(){return localStorage.setItem(this.storage,s.encode(await this.#e)),this}async unwrap(t,e,s={name:"RSA-OAEP"}){const a=await this.#s(e);return await crypto.subtle.unwrapKey("pkcs8",t,a,{name:"AES-GCM",iv:e},s,!0,["encrypt","decrypt","wrapKey","unwrapKey"])}async wrap(t,e){const s=await this.#s(e);return await crypto.subtle.wrapKey("pkcs8",t,s,{name:"AES-GCM",iv:e})}async#s(t){const e=await crypto.subtle.importKey("raw",await this.#e,"PBKDF2",!1,["deriveBits","deriveKey"]);return await crypto.subtle.deriveKey({salt:t,name:"PBKDF2",iterations:1e5,hash:"SHA-256"},e,{name:"AES-GCM",length:256},!0,["encrypt","decrypt","wrapKey","unwrapKey"])}}class i{constructor({privateKey:t,publicKey:e,salt:s}){this.privateKey=t,this.publicKey=e,this.salt=s}async export(t=null){t??=await a.recall();const e=t.wrap(this.privateKey,this.salt),i=crypto.subtle.exportKey("spki",this.publicKey);return{k:s.encode(await e),p:s.encode(await i),s:s.encode(this.salt)}}static async generate(){const[t,e]=await Promise.all([crypto.getRandomValues(new Uint8Array(16)),crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:"SHA-256"},!0,["encrypt","decrypt","wrapKey","unwrapKey"])]);return new this({salt:t,privateKey:e.privateKey,publicKey:e.publicKey})}static async import({k:t,p:e,s:i},r=null){r??=await a.recall();const n=s.decode(i),c=s.decode(e),o=s.decode(t),[p,h]=await Promise.all([r.unwrap(o,n),crypto.subtle.importKey("spki",c,{name:"RSA-OAEP",hash:"SHA-256"},!0,["encrypt","wrapKey"])]);return new this({privateKey:p,publicKey:h,salt:n})}}class r extends t{constructor(t,{cipher:e}){super(t),this.decrypt(i.import(e))}async decrypt(t){}}class n{static event=e.event;static targets={};static intercept(t){return new class{on(e){const s=n.targets[t]??=new WeakMap;return s.has(e)||(s.set(e,{callbacks:[]}),n.#a(t,e)),this.target=s.get(e),this}then(t){return this.target.callbacks.push(t),this}finally(t){this.target.final=t}}}static#a(t,e){e.addEventListener(t,(async s=>{s.preventDefault();const a=this.targets[t].get(e).callbacks.map((t=>t()));await Promise.all(a),e.dispatchEvent(new CustomEvent(this.event,{bubbles:!0,detail:{type:t}}))})),document.addEventListener(this.event,(s=>{s.target==e&&s.detail.type==t&&this.targets[t].get(e).final(s)}))}}class c extends t{get form(){return this.node.form}onSubmit(t){if(!this.form)throw new Error(`Cipher component "${this.constructor.name.toLowerCase()}" must be inside <form> element to intercept submit.`);n.intercept("submit").on(this.form).then(t.bind(this)).finally((()=>this.form.submit()))}}class o extends c{input(t){const e="data-cipher-input";return this.inputs(t).forEach((s=>s.setAttribute(e,t))),this.form.querySelector(`[${e}='${t}']`)}inputs(t){const e=this.form.elements.namedItem(t);return("function"==typeof e[Symbol.iterator]?[...e]:[e]).filter((t=>!this.node.contains(t)))}output(t,e,s=!0){const a=this.node.elements.namedItem(t)??document.createElement("input");return a.type="hidden",a.name=t,a.value=e,this.node.contains(a)||this.node.appendChild(a),s&&this.inputs(t).forEach((t=>t.removeAttribute("name"))),a}}class p extends o{constructor(t,{input:e,key:s}){super(t),this.input=e,this.publicKey=s,this.onSubmit(this.encrypt)}encrypt(){}}class h extends o{constructor(t,{password:e}){super(t),this.password=e,this.onSubmit(this.login)}async login(){const t=this.input(this.password).value,e=await a.hash(t).remember();this.output(this.password,s.encode(await e.hash))}}class u extends o{constructor(t,{password:e,confirmation:s}){super(t),this.password=e,this.confirmation=s,this.onSubmit(this.register)}async register(){const t=this.input(this.password).value,e=await a.hash(t).remember();if(this.output(this.password,s.encode(await e.hash)),this.confirmation){const t=this.input(this.confirmation).value,e=a.hash(t).hash;this.output(this.confirmation,s.encode(await e))}const r=await i.generate(),n=await r.export(e),c=JSON.stringify(n);this.output("_cipher",c)}}class l{static types={decrypt:r,encrypt:p,login:h,register:u};static load(){document.querySelectorAll("[data-cipher-component]").forEach((t=>{const e=t.dataset.cipherComponent;return new(0,this.types[e])(t,JSON.parse(t.dataset.cipherAttributes))}))}}document.addEventListener("DOMContentLoaded",(()=>{l.load()}))}));
//# sourceMappingURL=cipher.js.map
