{"version":3,"file":"keypad.js","sources":["../js/Components/Component.mjs","../js/Script.mjs","../js/Event.mjs","../js/Components/FormControl.mjs","../js/Components/Fieldset.mjs","../js/Util/base16.mjs","../js/Util/encode.mjs","../js/Password.mjs","../js/Util/sha256.mjs","../js/Keypad.mjs","../js/Components/ChangePassword.mjs","../js/Components/Decrypt.mjs","../js/Util/decode.mjs","../js/Components/Encrypt.mjs","../js/Components/Hash.mjs","../js/Components/Login.mjs","../js/Components/Register.mjs","../js/Components.mjs","../js/index.js"],"sourcesContent":["/**\n * @abstract\n */\nexport default class Component {\n    /**\n     * @param {HTMLElement} node \n     * @param {Object} _context \n     */\n    constructor(node, _context) {\n        /**\n         * @property {HTMLElement} node\n         */\n        this.node = node\n    }\n}","export default class Script {\n    static #script = document.currentScript\n\n    static data = this.#script.getAttribute('data')\n\n    static event = this.#script.getAttribute('event')\n\n    static salt = this.#script.getAttribute('salt')\n\n    static storage = this.#script.getAttribute('storage')\n}","import Script from \"./Script.mjs\"\n\n/**\n * Class responsible for managing events.\n */\nexport default class Event {\n    /**\n     * The name of the event that will be dispatched at the end of\n     * an event interception cycle and, unless stopped, will bubble\n     * to the root and trigger the \"final\" callback.\n     */\n    static event = Script.event\n\n    /** \n     * The event targets and their respective callback stacks, grouped by event type.\n     * \n     * @type {Object<string, WeakMap<EventTarget, {callbacks: ((event: Event) => any)[], final?: (event: Event) => any}>>}\n     */\n    static targets = {}\n\n    /**\n     * Fluently begin constructing a new event interception definition.\n     * \n     * @param {string} event \n     * @returns \n     */\n    static intercept(event) {\n        return new class {\n            /**\n             * Set the event target.\n             * \n             * @param {EventTarget} target \n             * @returns {this}\n             */\n            on(target) {\n                const targets = Event.targets[event] ??= new WeakMap\n\n                if (!targets.has(target)) {\n                    targets.set(target, {\n                        callbacks: []\n                    })\n\n                    Event.#listen(event, target)\n                }\n\n                this.target = targets.get(target)\n\n                return this\n            }\n\n            /**\n             * Add a callback to be run while intercepting event.\n             * \n             * @param {(event: Event) => any} callback \n             * @returns \n             */\n            then(callback) {\n                this.target.callbacks.push(callback)\n\n                return this\n            }\n\n            /**\n             * Set the callback to be run at the end once.\n             * \n             * @param {(event: Event) => any} callback \n             */\n            finally(callback) {\n                this.target.final = callback\n            }\n        }\n    }\n\n    /**\n     * Add the event listener for the given event type and target.\n     * \n     * @param {string} type\n     * @param {EventTarget} target \n     */\n    static #listen(type, target) {\n        target.addEventListener(type, async event => {\n            event.preventDefault()\n\n            const\n                targets = this.targets[type],\n                listener = targets.get(target),\n                callbacks = listener.callbacks,\n                promises = callbacks.map(callback => callback())\n\n            await Promise.all(promises)\n\n            target.dispatchEvent(new CustomEvent(this.event, {\n                bubbles: true,\n                detail: { type }\n            }))\n        })\n\n        document.addEventListener(this.event, event => {\n            if (\n                event.target != target ||\n                event.detail.type != type\n            ) {\n                return\n            }\n\n            this.targets[type].get(target).final(event)\n        })\n    }\n}","import Component from \"./Component.mjs\";\nimport Event from \"../Event.mjs\";\n\n/**\n * @abstract\n */\nexport default class FormControl extends Component {\n    /** @type {HTMLFormElement} */\n    form = this.node.form\n\n    /**\n     * Intercept the submit event for the component's form using the given callback.\n     * \n     * @param {(event: Event) => any} callback \n     * @returns {void}\n     */\n    onSubmit(callback) {\n        if (!this.form) {\n            throw new Error(`Keypad component \"${this.constructor.name.toLowerCase()}\" must be inside <form> element to intercept submit.`)\n        }\n\n        Event.intercept('submit')\n            .on(this.form)\n            .then(callback.bind(this))\n            .finally(() => this.form.submit())\n    }\n}","import FormControl from \"./FormControl.mjs\";\n\n/**\n * @abstract\n * @property {HTMLFieldSetElement} node\n */\nexport default class Fieldset extends FormControl {\n    /**\n     * Get the form input element with given name.\n     * \n     * @param {string} name \n     * @returns \n     */\n    input(name) {\n        const\n            attribute = 'data-keypad-input',\n            items = this.#inputs(name)\n\n        items.forEach(item => item.setAttribute(attribute, name))\n\n        return this.form.querySelector(`[${attribute}='${name}']`)\n    }\n\n    /**\n     * Get all the form control elements with the given name.\n     * \n     * @param {string} name \n     * @returns {HTMLElement[]}\n     */\n    #inputs(name) {\n        const\n            item = this.form.elements.namedItem(name),\n            items = typeof item[Symbol.iterator] === 'function'\n                ? [...item]\n                : [item]\n\n        return items.filter(item => !this.node.contains(item))\n    }\n\n    /**\n     * Append to fieldset 'output' field of given \"name\" and \"value\".\n     * \n     * @param {string} name \n     * @param {string} value \n     * @param {boolean} overwrite\n     * @returns \n     */\n    output(name, value, overwrite = true) {\n        const output = this.node.elements.namedItem(name) ?? document.createElement('input')\n\n        output.type = 'hidden'\n        output.name = name\n        output.value = value\n\n        if (!this.node.contains(output)) {\n            this.node.appendChild(output)\n        }\n\n        if (overwrite) {\n            this.#inputs(name).forEach(item => item.removeAttribute('name'))\n        }\n\n        return output\n    }\n}","/**\n * Class responsible for encoding and decoding base16 (hexadecimal).\n */\nexport default class base16 {\n    static encode(data) {\n        return Array\n            .from(new Uint8Array(data))\n            .map((b) => b.toString(16).padStart(2, '0'))\n            .join('')\n    }\n\n    static decode(string) {\n        return new Uint8Array(string.match(/../g).map(h => parseInt(h, 16))).buffer\n    }\n}","export default function encode(value) {\n    return new TextEncoder().encode(value)\n}","import Script from \"./Script.mjs\";\n\nimport base16 from \"./Util/base16.mjs\";\nimport encode from \"./Util/encode.mjs\";\nimport sha256 from \"./Util/sha256.mjs\";\n\nexport default class Password {\n    /** @type {Promise<ArrayBuffer>} - The private, client-side password hash. */\n    #hash\n\n    /** @type {Promise<ArrayBuffer> | null} - The 'shareable', server-side password hash. */\n    hash\n\n    static salt = Script.salt\n\n    static storage = Script.storage\n\n    static token = Script.token\n\n    /**\n     * @param {{ clientHash: ArrayBufferLike, serverHash: ArrayBufferLike }} param0 \n     */\n    constructor({ clientHash, serverHash = null }) {\n        this.#hash = clientHash\n\n        this.hash = serverHash\n    }\n\n    /**\n     * Initialize a password instance by hashing a plaintext password.\n     * \n     * @param {string} plaintext \n     * @returns {Password}\n     */\n    static hash(plaintext) {\n        const\n            salt = this.salt,\n            hash = input => sha256(encode(input)),\n            clientHash = hash(plaintext + salt),\n            serverHash = hash(salt + plaintext)\n\n        return new this({ clientHash, serverHash })\n    }\n\n    /**\n     * Recall a previously stored instance from local storage.\n     * \n     * @returns {Password}\n     */\n    static recall() {\n        const\n            stored = this.retrieve(),\n            clientHash = base16.decode(stored.pop())\n\n        return new this({ clientHash })\n    }\n\n    /**\n     * Store the password hash in local storage, so it may be\n     * recalled in a subsequent request post-authentication.\n     * \n     * @param {{ append: Boolean }}\n     * @returns {Promise<Password>}\n     */\n    async remember({ append = false } = {}) {\n        const\n            key = Password.storage,\n            stored = append ? Password.retrieve() : [],\n            hash = base16.encode(await this.#hash),\n            value = stored.filter(value => value != hash).concat(hash)\n\n        localStorage.setItem(\n            key,\n            value\n        )\n\n        return this\n    }\n\n    /**\n     * Restore the instance from a previously stored hash,\n     * and return true if successful.\n     * \n     * @returns {Promise<Boolean>}\n     */\n    async restore() {\n        const\n            hash = base16.encode(await this.#hash),\n            stored = Password.retrieve(),\n            index = stored.indexOf(hash)\n\n        if (index < 1) {\n            return false;\n        }\n\n        this.#hash = base16.decode(stored[index - 1])\n\n        return true\n    }\n\n    /**\n     * Retrieve stored hashes from local storage.\n     * \n     * @returns {Array<string>}\n     */\n    static retrieve() {\n        /** @var {string | null} */\n        const stored = localStorage.getItem(this.storage)\n\n        return stored ? stored.split(',') : []\n    }\n\n    /**\n     * Use the password to unwrap (decrypt) the given wrapped key using the given salt.\n     * \n     * @param {ArrayBufferLike} wrappedKey \n     * @param {ArrayBufferLike} salt \n     * @returns \n     */\n    async unwrap(wrappedKey, salt, unwrappedKeyAlgorithm = { name: 'RSA-OAEP', hash: 'SHA-256' }) {\n        try {\n            const\n                unwrappingKey = await this.#wrappingKey(salt),\n                unwrappedKey = await crypto.subtle.unwrapKey(\n                    'pkcs8',\n                    wrappedKey,\n                    unwrappingKey,\n                    { name: 'AES-GCM', iv: salt },\n                    unwrappedKeyAlgorithm,\n                    true,\n                    ['decrypt']\n                )\n\n            return unwrappedKey\n        } catch (error) {\n            // If the operation failed, it may be because the password was recently changed.\n            // So we attempt to restore to a previous password hash, and try again\n            if (await this.restore()) {\n                return await this.unwrap(wrappedKey, salt, unwrappedKeyAlgorithm)\n            }\n\n            throw error\n        }\n    }\n\n    /**\n     * Use the password to wrap (encrypt) the given key using the given salt.\n     * \n     * @param {CryptoKey} key \n     * @param {ArrayBufferLike} salt \n     */\n    async wrap(key, salt) {\n        const\n            wrappingKey = await this.#wrappingKey(salt),\n            wrappedKey = await crypto.subtle.wrapKey(\n                'pkcs8',\n                key,\n                wrappingKey,\n                { name: 'AES-GCM', iv: salt }\n            )\n\n        return wrappedKey\n    }\n\n    /**\n     * Get the wrapping key for the given salt.\n     * \n     * @param {ArrayBufferLike} salt \n     * @returns {Promise<CryptoKey>}\n     */\n    async #wrappingKey(salt) {\n        const baseKey = await crypto.subtle.importKey(\n            'raw',\n            await this.#hash,\n            'PBKDF2',\n            false,\n            ['deriveBits', 'deriveKey'],\n        )\n\n        return await crypto.subtle.deriveKey(\n            {\n                salt,\n                name: 'PBKDF2',\n                iterations: 100000,\n                hash: 'SHA-256',\n            },\n            baseKey,\n            { 'name': 'AES-GCM', 'length': 256 },\n            true,\n            ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey'],\n        )\n    }\n}","export default function sha256(data) {\n    return crypto.subtle.digest(\n        'SHA-256',\n        data\n    )\n}","import Password from \"./Password.mjs\"\nimport Script from \"./Script.mjs\"\n\nimport base16 from \"./Util/base16.mjs\"\n\nexport default class Keypad {\n    /**\n     * @param {{ privateKey: CryptoKey, publicKey: CryptoKey }}\n     */\n    constructor({ privateKey, publicKey }) {\n        this.privateKey = privateKey\n\n        this.publicKey = publicKey\n    }\n\n    /**\n     * Encrypt sensitive data using the given password and export the data.\n     * \n     * @param {Password} [password]\n     * @returns {Promise<{ k: string, p: string, s: string }>}\n     */\n    async export(password = null) {\n        password ??= Password.recall()\n\n        const\n            salt = crypto.getRandomValues(new Uint8Array(16)),\n            wrappedPrivateKey = password.wrap(this.privateKey, salt),\n            exportedPublicKey = crypto.subtle.exportKey(\n                'spki',\n                this.publicKey\n            )\n\n        return {\n            k: base16.encode(await wrappedPrivateKey),\n            p: base16.encode(await exportedPublicKey),\n            s: base16.encode(salt)\n        }\n    }\n\n    /**\n     * Generate a new keypad.\n     * \n     * @returns {Promise<Keypad>}\n     */\n    static async generate() {\n        const\n            keyPair = await crypto.subtle.generateKey(\n                {\n                    name: 'RSA-OAEP',\n                    modulusLength: 4096,\n                    publicExponent: new Uint8Array([1, 0, 1]),\n                    hash: 'SHA-256'\n                },\n                true,\n                ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']\n            ),\n            privateKey = keyPair.privateKey,\n            publicKey = keyPair.publicKey\n\n        return new this({ privateKey, publicKey })\n    }\n\n    /**\n     * Parse and decrypt previously exported keypad data using the given password.\n     * \n     * @param {{ k: string, p: string, s: string }}\n     * @param {Password} [password]\n     * @returns {Promise<Keypad>}\n     */\n    static async import({ k, p, s }, password = null) {\n        password ??= Password.recall()\n\n        const\n            salt = base16.decode(s),\n            exportedPublicKey = base16.decode(p),\n            wrappedPrivateKey = base16.decode(k)\n\n        const [privateKey, publicKey] = await Promise.all([\n            password.unwrap(wrappedPrivateKey, salt),\n            crypto.subtle.importKey(\n                'spki',\n                exportedPublicKey,\n                {\n                    name: 'RSA-OAEP',\n                    hash: 'SHA-256'\n                },\n                true,\n                ['encrypt', 'wrapKey']\n            )\n        ])\n\n        return new this({\n            privateKey,\n            publicKey,\n        })\n    }\n\n    /**\n     * Resolve the keypad of currently authenticated user.\n     * \n     * @returns {Promise<Keypad> | null}\n     */\n    static resolve() {\n        const json = Script.data\n\n        return json\n            ? this.import(JSON.parse(json))\n            : null\n    }\n}","import Fieldset from \"./Fieldset.mjs\";\nimport Keypad from \"../Keypad.mjs\";\nimport Password from \"../Password.mjs\";\n\nexport default class ChangePassword extends Fieldset {\n    constructor(node, { password }) {\n        super(node)\n\n        this.password = password\n\n        this.onSubmit(this.changePassword)\n    }\n\n    async changePassword() {\n        const\n            keypad = await Keypad.resolve(),\n            plaintextPassword = this.input(this.password).value\n\n        const\n            password = await Password.hash(plaintextPassword).remember({ append: true }),\n            exported = await keypad.export(password),\n            json = JSON.stringify(exported)\n\n        this.output('_keypad', json)\n    }\n}","import Component from \"./Component.mjs\";\n\nimport base16 from \"../Util/base16.mjs\";\nimport Keypad from \"../Keypad.mjs\";\nimport decode from \"../Util/decode.mjs\";\n\nexport default class Decrypt extends Component {\n    constructor(node) {\n        super(node)\n\n        this.decrypt()\n    }\n\n    async decrypt() {\n        const\n            keypad = await Keypad.resolve(),\n            privateKey = keypad.privateKey,\n            ciphertext = base16.decode(this.node.innerText),\n            plaintext = await crypto.subtle.decrypt(\n                { name: 'RSA-OAEP' },\n                privateKey,\n                ciphertext\n            )\n\n        this.node.innerText = decode(plaintext)\n\n        this.node.hidden = false\n    }\n}","export default function decode(value) {\n    return new TextDecoder().decode(value)\n}","import Fieldset from \"./Fieldset.mjs\";\n\nimport base16 from \"../Util/base16.mjs\";\nimport encode from \"../Util/encode.mjs\";\n\nexport default class Encrypt extends Fieldset {\n    constructor(node, { target, key }) {\n        super(node)\n\n        this.target = target\n\n        this.publicKey = key\n\n        this.onSubmit(this.encrypt)\n    }\n\n    async encrypt() {\n        const\n            plaintext = this.input(this.target).value,\n            publicKey = await crypto.subtle.importKey(\n                'spki',\n                base16.decode(this.publicKey),\n                {\n                    name: 'RSA-OAEP',\n                    hash: 'SHA-256'\n                },\n                true,\n                ['encrypt']\n            ),\n            ciphertext = await crypto.subtle.encrypt(\n                { name: 'RSA-OAEP' },\n                publicKey,\n                encode(plaintext)\n            )\n\n        this.output(this.target, base16.encode(ciphertext))\n    }\n}","import Fieldset from \"./Fieldset.mjs\";\nimport Password from \"../Password.mjs\";\n\nimport base16 from \"../Util/base16.mjs\";\n\nexport default class Hash extends Fieldset {\n    constructor(node, { target }) {\n        super(node)\n\n        this.target = target\n\n        this.onSubmit(this.hash)\n    }\n\n    async hash() {\n        const\n            message = this.input(this.target).value,\n            password = Password.hash(message)\n\n        this.output(this.target, base16.encode(await password.hash))\n    }\n}","import Fieldset from \"./Fieldset.mjs\";\nimport Password from \"../Password.mjs\";\n\nexport default class Login extends Fieldset {\n    constructor(node, { password }) {\n        super(node)\n\n        this.password = password\n\n        this.onSubmit(this.login)\n    }\n\n    async login() {\n        const plaintextPassword = this.input(this.password).value\n\n        await Password.hash(plaintextPassword).remember()\n    }\n}","import Keypad from \"../Keypad.mjs\";\nimport Fieldset from \"./Fieldset.mjs\";\nimport Password from \"../Password.mjs\";\n\nexport default class Register extends Fieldset {\n    constructor(node, { password }) {\n        super(node)\n\n        this.password = password\n\n        this.onSubmit(this.register)\n    }\n\n    async register() {\n        const\n            plaintextPassword = this.input(this.password).value,\n            password = await Password.hash(plaintextPassword).remember(),\n            keypad = await Keypad.generate(),\n            exported = await keypad.export(password),\n            json = JSON.stringify(exported)\n\n        this.output('_keypad', json)\n    }\n}","import ChangePassword from \"./Components/ChangePassword.mjs\"\nimport Component from \"./Components/Component.mjs\"\nimport Decrypt from \"./Components/Decrypt.mjs\"\nimport Encrypt from \"./Components/Encrypt.mjs\"\nimport Hash from \"./Components/Hash.mjs\"\nimport Login from \"./Components/Login.mjs\"\nimport Register from \"./Components/Register.mjs\"\n\n/**\n * Class responsible for mapping and loading the keypad components.\n */\nexport default class Components {\n    /**\n     * @type {Object.<string, typeof Component>}\n     */\n    static types = {\n        'change-password': ChangePassword,\n        decrypt: Decrypt,\n        encrypt: Encrypt,\n        hash: Hash,\n        login: Login,\n        register: Register,\n    }\n\n    /**\n     * Load components on the page.\n     */\n    static load() {\n        document.querySelectorAll('[data-keypad-component]').forEach(node => {\n            const\n                name = node.dataset.keypadComponent,\n                type = this.types[name],\n                attributes = JSON.parse(node.dataset.keypadAttributes),\n                component = new type(node, attributes)\n\n            return component\n        })\n    }\n}","import Components from \"./Components.mjs\";\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    Components.load()\n})"],"names":["Component","constructor","node","_context","this","Script","static","document","currentScript","script","getAttribute","Event","event","on","target","targets","WeakMap","has","set","callbacks","listen","get","then","callback","push","finally","final","type","addEventListener","async","preventDefault","promises","map","Promise","all","dispatchEvent","CustomEvent","bubbles","detail","FormControl","form","onSubmit","Error","name","toLowerCase","intercept","bind","submit","Fieldset","input","attribute","inputs","forEach","item","setAttribute","querySelector","elements","namedItem","Symbol","iterator","filter","contains","output","value","overwrite","createElement","appendChild","removeAttribute","base16","data","Array","from","Uint8Array","b","toString","padStart","join","string","match","h","parseInt","buffer","encode","TextEncoder","Password","hash","salt","storage","token","clientHash","serverHash","plaintext","sha256","crypto","subtle","digest","stored","retrieve","decode","pop","append","key","concat","localStorage","setItem","index","indexOf","getItem","split","wrappedKey","unwrappedKeyAlgorithm","unwrappingKey","wrappingKey","unwrapKey","iv","error","restore","unwrap","wrapKey","baseKey","importKey","deriveKey","iterations","length","Keypad","privateKey","publicKey","password","recall","getRandomValues","wrappedPrivateKey","wrap","exportedPublicKey","exportKey","k","p","s","keyPair","generateKey","modulusLength","publicExponent","json","import","JSON","parse","ChangePassword","super","changePassword","keypad","resolve","plaintextPassword","remember","exported","export","stringify","Decrypt","decrypt","ciphertext","innerText","TextDecoder","hidden","Encrypt","encrypt","Hash","message","Login","login","Register","register","generate","Components","querySelectorAll","dataset","keypadComponent","types","keypadAttributes","component","load"],"mappings":"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"}