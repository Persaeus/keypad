!function(t){"function"==typeof define&&define.amd?define(t):t()}((function(){"use strict";class t{constructor(t,e){this.node=t}}class e{static#t=document.currentScript;static event=this.#t.getAttribute("event");static salt=this.#t.getAttribute("salt");static storage=this.#t.getAttribute("storage");static token=this.#t.getAttribute("token")}class s{static encode(t){return Array.from(new Uint8Array(t)).map((t=>t.toString(16).padStart(2,"0"))).join("")}static decode(t){return new Uint8Array(t.match(/../g).map((t=>parseInt(t,16)))).buffer}}function a(t){return(new TextEncoder).encode(t)}class r{#e;hash;static salt=e.salt;static storage=e.storage;static token=e.token;constructor({clientHash:t,serverHash:e=null}){this.#e=t,this.hash=e}static hash(t){const e=this.salt,s=t=>{return e=a(t),crypto.subtle.digest("SHA-256",e);var e};return new this({clientHash:s(t+e),serverHash:s(e+t)})}static async recall(){const t=this.#s(),e=s.decode(t.iv),a=s.decode(t.encryptedHash),r=await this.#a(e);return new this({clientHash:await crypto.subtle.decrypt({name:"AES-GCM",iv:e},r,a)})}async remember(){const t=crypto.getRandomValues(new Uint8Array(16)),e=await r.#a(t),s=await crypto.subtle.encrypt({name:"AES-GCM",iv:t},e,await this.#e);return r.#r(t,s),this}static#s(){return JSON.parse(localStorage.getItem(this.storage))}static async#a(t){console.log(this.token);const e=await crypto.subtle.importKey("raw",a(this.token),"HKDF",!1,["deriveBits","deriveKey"]);return await crypto.subtle.deriveKey({hash:"SHA-256",info:new ArrayBuffer,name:"HKDF",salt:t},e,{name:"AES-GCM",length:256},!0,["encrypt","decrypt","wrapKey","unwrapKey"])}static#r(t,e){localStorage.setItem(this.storage,JSON.stringify({iv:s.encode(t),encryptedHash:s.encode(e)}))}async unwrap(t,e,s={name:"RSA-OAEP"}){const a=await this.#i(e);return await crypto.subtle.unwrapKey("pkcs8",t,a,{name:"AES-GCM",iv:e},s,!0,["encrypt","decrypt","wrapKey","unwrapKey"])}async wrap(t,e){const s=await this.#i(e);return await crypto.subtle.wrapKey("pkcs8",t,s,{name:"AES-GCM",iv:e})}async#i(t){const e=await crypto.subtle.importKey("raw",await this.#e,"PBKDF2",!1,["deriveBits","deriveKey"]);return await crypto.subtle.deriveKey({salt:t,name:"PBKDF2",iterations:1e5,hash:"SHA-256"},e,{name:"AES-GCM",length:256},!0,["encrypt","decrypt","wrapKey","unwrapKey"])}}class i{constructor({privateKey:t,publicKey:e,salt:s}){this.privateKey=t,this.publicKey=e,this.salt=s}async export(t=null){t??=await r.recall();const e=t.wrap(this.privateKey,this.salt),a=crypto.subtle.exportKey("spki",this.publicKey);return{k:s.encode(await e),p:s.encode(await a),s:s.encode(this.salt)}}static async generate(){const[t,e]=await Promise.all([crypto.getRandomValues(new Uint8Array(16)),crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:"SHA-256"},!0,["encrypt","decrypt","wrapKey","unwrapKey"])]);return new this({salt:t,privateKey:e.privateKey,publicKey:e.publicKey})}static async import({k:t,p:e,s:a},i=null){i??=await r.recall();const n=s.decode(a),c=s.decode(e),o=s.decode(t),[p,h]=await Promise.all([i.unwrap(o,n),crypto.subtle.importKey("spki",c,{name:"RSA-OAEP",hash:"SHA-256"},!0,["encrypt","wrapKey"])]);return new this({privateKey:p,publicKey:h,salt:n})}}class n extends t{constructor(t,{cipher:e}){super(t),this.decrypt(i.import(e))}async decrypt(t){}}class c{static event=e.event;static targets={};static intercept(t){return new class{on(e){const s=c.targets[t]??=new WeakMap;return s.has(e)||(s.set(e,{callbacks:[]}),c.#n(t,e)),this.target=s.get(e),this}then(t){return this.target.callbacks.push(t),this}finally(t){this.target.final=t}}}static#n(t,e){e.addEventListener(t,(async s=>{s.preventDefault();const a=this.targets[t].get(e).callbacks.map((t=>t()));await Promise.all(a),e.dispatchEvent(new CustomEvent(this.event,{bubbles:!0,detail:{type:t}}))})),document.addEventListener(this.event,(s=>{s.target==e&&s.detail.type==t&&this.targets[t].get(e).final(s)}))}}class o extends t{get form(){return this.node.form}onSubmit(t){if(!this.form)throw new Error(`Cipher component "${this.constructor.name.toLowerCase()}" must be inside <form> element to intercept submit.`);c.intercept("submit").on(this.form).then(t.bind(this)).finally((()=>this.form.submit()))}}class p extends o{input(t){const e="data-cipher-input";return this.inputs(t).forEach((s=>s.setAttribute(e,t))),this.form.querySelector(`[${e}='${t}']`)}inputs(t){const e=this.form.elements.namedItem(t);return("function"==typeof e[Symbol.iterator]?[...e]:[e]).filter((t=>!this.node.contains(t)))}output(t,e,s=!0){const a=this.node.elements.namedItem(t)??document.createElement("input");return a.type="hidden",a.name=t,a.value=e,this.node.contains(a)||this.node.appendChild(a),s&&this.inputs(t).forEach((t=>t.removeAttribute("name"))),a}}class h extends p{constructor(t,{input:e,key:s}){super(t),this.input=e,this.publicKey=s,this.onSubmit(this.encrypt)}encrypt(){}}class u extends p{constructor(t,{password:e}){super(t),this.password=e,this.onSubmit(this.login)}async login(){const t=this.input(this.password).value,e=await r.hash(t).remember();this.output(this.password,s.encode(await e.hash))}}class l extends p{constructor(t,{password:e,confirmation:s}){super(t),this.password=e,this.confirmation=s,this.onSubmit(this.register)}async register(){const t=this.input(this.password).value,e=await r.hash(t).remember();if(this.output(this.password,s.encode(await e.hash)),this.confirmation){const t=this.input(this.confirmation).value,e=r.hash(t).hash;this.output(this.confirmation,s.encode(await e))}const a=await i.generate(),n=await a.export(e),c=JSON.stringify(n);this.output("_cipher",c)}}class y{static types={decrypt:n,encrypt:h,login:u,register:l};static load(){document.querySelectorAll("[data-cipher-component]").forEach((t=>{const e=t.dataset.cipherComponent;return new(0,this.types[e])(t,JSON.parse(t.dataset.cipherAttributes))}))}}document.addEventListener("DOMContentLoaded",(()=>{y.load()}))}));
//# sourceMappingURL=cipher.js.map
