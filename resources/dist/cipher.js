!function(t){"function"==typeof define&&define.amd?define(t):t()}((function(){"use strict";class t{constructor(t,e){this.node=t}}class e{static encode(t){return Array.from(new Uint8Array(t)).map((t=>t.toString(16).padStart(2,"0"))).join("")}static decode(t){return new Uint8Array(t.match(/../g).map((t=>parseInt(t,16)))).buffer}}class s{static#t=document.currentScript;static data=this.#t.getAttribute("data");static event=this.#t.getAttribute("event");static salt=this.#t.getAttribute("salt");static storage=this.#t.getAttribute("storage")}function a(t){return(new TextEncoder).encode(t)}class i{#e;hash;static salt=s.salt;static storage=s.storage;static token=s.token;constructor({clientHash:t,serverHash:e=null}){this.#e=t,this.hash=e}static hash(t){const e=this.salt,s=t=>{return e=a(t),crypto.subtle.digest("SHA-256",e);var e};return new this({clientHash:s(t+e),serverHash:s(e+t)})}static async recall(){const t=localStorage.getItem(this.storage);return new this({clientHash:e.decode(t)})}async remember(){return localStorage.setItem(i.storage,e.encode(await this.#e)),this}async unwrap(t,e,s={name:"RSA-OAEP",hash:"SHA-256"}){const a=await this.#s(e);return await crypto.subtle.unwrapKey("pkcs8",t,a,{name:"AES-GCM",iv:e},s,!0,["decrypt"])}async wrap(t,e){const s=await this.#s(e);return await crypto.subtle.wrapKey("pkcs8",t,s,{name:"AES-GCM",iv:e})}async#s(t){const e=await crypto.subtle.importKey("raw",await this.#e,"PBKDF2",!1,["deriveBits","deriveKey"]);return await crypto.subtle.deriveKey({salt:t,name:"PBKDF2",iterations:1e5,hash:"SHA-256"},e,{name:"AES-GCM",length:256},!0,["encrypt","decrypt","wrapKey","unwrapKey"])}}class r{constructor({privateKey:t,publicKey:e,salt:s}){this.privateKey=t,this.publicKey=e,this.salt=s}async export(t=null){t??=await i.recall();const s=t.wrap(this.privateKey,this.salt),a=crypto.subtle.exportKey("spki",this.publicKey);return{k:e.encode(await s),p:e.encode(await a),s:e.encode(this.salt)}}static async generate(){const[t,e]=await Promise.all([crypto.getRandomValues(new Uint8Array(16)),crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:"SHA-256"},!0,["encrypt","decrypt","wrapKey","unwrapKey"])]);return new this({salt:t,privateKey:e.privateKey,publicKey:e.publicKey})}static async import({k:t,p:s,s:a},r=null){r??=await i.recall();const n=e.decode(a),c=e.decode(s),o=e.decode(t),[h,p]=await Promise.all([r.unwrap(o,n),crypto.subtle.importKey("spki",c,{name:"RSA-OAEP",hash:"SHA-256"},!0,["encrypt","wrapKey"])]);return new this({privateKey:h,publicKey:p,salt:n})}static resolve(){const t=s.data;return t?this.import(JSON.parse(t)):null}}class n extends t{constructor(t){super(t),this.decrypt()}async decrypt(){const t=(await r.resolve()).privateKey,s=e.decode(this.node.innerText),a=await crypto.subtle.decrypt({name:"RSA-OAEP"},t,s);var i;this.node.innerText=(i=a,(new TextDecoder).decode(i)),this.node.hidden=!1}}class c{static event=s.event;static targets={};static intercept(t){return new class{on(e){const s=c.targets[t]??=new WeakMap;return s.has(e)||(s.set(e,{callbacks:[]}),c.#a(t,e)),this.target=s.get(e),this}then(t){return this.target.callbacks.push(t),this}finally(t){this.target.final=t}}}static#a(t,e){e.addEventListener(t,(async s=>{s.preventDefault();const a=this.targets[t].get(e).callbacks.map((t=>t()));await Promise.all(a),e.dispatchEvent(new CustomEvent(this.event,{bubbles:!0,detail:{type:t}}))})),document.addEventListener(this.event,(s=>{s.target==e&&s.detail.type==t&&this.targets[t].get(e).final(s)}))}}class o extends t{get form(){return this.node.form}onSubmit(t){if(!this.form)throw new Error(`Cipher component "${this.constructor.name.toLowerCase()}" must be inside <form> element to intercept submit.`);c.intercept("submit").on(this.form).then(t.bind(this)).finally((()=>this.form.submit()))}}class h extends o{input(t){const e="data-cipher-input";return this.inputs(t).forEach((s=>s.setAttribute(e,t))),this.form.querySelector(`[${e}='${t}']`)}inputs(t){const e=this.form.elements.namedItem(t);return("function"==typeof e[Symbol.iterator]?[...e]:[e]).filter((t=>!this.node.contains(t)))}output(t,e,s=!0){const a=this.node.elements.namedItem(t)??document.createElement("input");return a.type="hidden",a.name=t,a.value=e,this.node.contains(a)||this.node.appendChild(a),s&&this.inputs(t).forEach((t=>t.removeAttribute("name"))),a}}class p extends h{constructor(t,{target:e,key:s}){super(t),this.target=e,this.publicKey=s,this.onSubmit(this.encrypt)}async encrypt(){const t=this.input(this.target).value,s=await crypto.subtle.importKey("spki",e.decode(this.publicKey),{name:"RSA-OAEP",hash:"SHA-256"},!0,["encrypt"]),i=await crypto.subtle.encrypt({name:"RSA-OAEP"},s,a(t));this.output(this.target,e.encode(i))}}class u extends h{constructor(t,{password:e}){super(t),this.password=e,this.onSubmit(this.login)}async login(){const t=this.input(this.password).value,s=await i.hash(t).remember();this.output(this.password,e.encode(await s.hash))}}class l extends h{constructor(t,{password:e,confirmation:s}){super(t),this.password=e,this.confirmation=s,this.onSubmit(this.register)}async register(){const t=this.input(this.password).value,s=await i.hash(t).remember();if(this.output(this.password,e.encode(await s.hash)),this.confirmation){const t=this.input(this.confirmation).value,s=i.hash(t).hash;this.output(this.confirmation,e.encode(await s))}const a=await r.generate(),n=await a.export(s),c=JSON.stringify(n);this.output("_cipher",c)}}class d{static types={decrypt:n,encrypt:p,login:u,register:l};static load(){document.querySelectorAll("[data-cipher-component]").forEach((t=>{const e=t.dataset.cipherComponent;return new(0,this.types[e])(t,JSON.parse(t.dataset.cipherAttributes))}))}}document.addEventListener("DOMContentLoaded",(()=>{d.load()}))}));
//# sourceMappingURL=cipher.js.map
